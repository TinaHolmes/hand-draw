<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI éš”ç©ºæ‰‹åŠ¿ç»˜å›¾ç³»ç»Ÿ</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #222; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #container { position: relative; width: 100vw; height: 100vh; }
        
        /* è§†é¢‘å±‚ï¼šæ°´å¹³ç¿»è½¬ä»¥è·å¾—é•œåƒä½“éªŒ */
        #input_video { position: absolute; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); display: none; }
        
        /* ç”»å¸ƒå±‚ */
        #output_canvas { position: absolute; left: 0; top: 0; width: 100%; height: 100%; transform: scaleX(-1); }
        
        /* åŠ è½½æç¤º */
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 24px; text-align: center;
            background: rgba(0,0,0,0.7); padding: 20px; border-radius: 10px; z-index: 100;
        }

        /* ç®€å•çš„æ“ä½œæŒ‡å—æµ®å±‚ */
        #guide {
            position: absolute; bottom: 10px; left: 10px; color: rgba(255,255,255,0.8);
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px; font-size: 14px;
            pointer-events: none; z-index: 50;
        }
    </style>
</head>
<body>

<div id="container">
    <div id="loading">æ­£åœ¨åˆå§‹åŒ– AI æ¨¡å‹å’Œæ‘„åƒå¤´...<br>è¯·ç¨å€™ï¼Œä¸”å…è®¸æ‘„åƒå¤´æƒé™ã€‚</div>
    <video id="input_video"></video>
    <canvas id="output_canvas"></canvas>
    
    <div id="guide">
        <b>æ‰‹åŠ¿è¯´æ˜ï¼š</b><br>
        ğŸ–ï¸ å¼ å¼€æ‰‹æŒï¼šæ‰“å¼€/å…³é—­ èœå•<br>
        ğŸ‘† é£ŸæŒ‡æ‚¬åœï¼šé€‰æ‹©èœå•åŠŸèƒ½<br>
        ğŸ‘Œ æ‹‡æŒ‡é£ŸæŒ‡æåˆï¼šå†™å­— / ä½¿ç”¨æ©¡çš®<br>
        âœŒï¸ å‰ªåˆ€æ‰‹ï¼ˆé£ŸæŒ‡+ä¸­æŒ‡ï¼‰ï¼šé›ªèŠ±æ¶ˆæ•£æ¸…å±<br>
        â˜ï¸...â˜ï¸ åŒæ‰‹é£ŸæŒ‡ï¼šç¼©æ”¾ç”»å¸ƒ
    </div>
</div>

<script>
    // --- 1. åˆå§‹åŒ–å˜é‡ ---
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const loadingDiv = document.getElementById('loading');

    // çŠ¶æ€ç®¡ç†
    const state = {
        isMenuOpen: false,
        mode: 'IDLE', // IDLE, WRITING, ERASING, ZOOMING, DISSOLVING
        menuCooldown: 0, // é˜²æ­¢èœå•é¢‘ç¹é—ªçƒ
        tool: 'PEN', // PEN, ERASER
        color: '#00FF00',
        lineWidth: 5,
        scale: 1, // ç¼©æ”¾æ¯”ä¾‹
        baseScale: 1, // ç¼©æ”¾åŸºå‡†
        zoomStartDist: 0 // åŒæ‰‹ç¼©æ”¾èµ·å§‹è·ç¦»
    };

    // ç¬”è¿¹æ•°æ®: Array of { points: [{x,y}], color, size, type }
    let strokes = []; 
    let currentStroke = null;

    // ç²’å­ç³»ç»Ÿ (ç”¨äºé›ªèŠ±æ¶ˆæ•£)
    let particles = [];
    let isDissolving = false;

    // UI é…ç½®
    const uiConfig = {
        x: 0.1, y: 0.1, width: 0.8, height: 0.8,
        buttons: [
            { id: 'tool_pen', text: 'âœï¸ ç¬”', x: 0.15, y: 0.2, w: 0.2, h: 0.15, action: () => { state.tool = 'PEN'; } },
            { id: 'tool_eraser', text: 'ğŸ§½ æ©¡çš®', x: 0.4, y: 0.2, w: 0.2, h: 0.15, action: () => { state.tool = 'ERASER'; } },
            // é¢œè‰²
            { id: 'col_red', color: '#FF0000', x: 0.15, y: 0.4, w: 0.1, h: 0.1, type: 'color' },
            { id: 'col_green', color: '#00FF00', x: 0.28, y: 0.4, w: 0.1, h: 0.1, type: 'color' },
            { id: 'col_blue', color: '#0000FF', x: 0.41, y: 0.4, w: 0.1, h: 0.1, type: 'color' },
            { id: 'col_yellow', color: '#FFFF00', x: 0.54, y: 0.4, w: 0.1, h: 0.1, type: 'color' },
            // å¤§å°
            { id: 'size_small', text: 'ç»†', x: 0.15, y: 0.6, w: 0.1, h: 0.1, action: () => { state.lineWidth = 3; } },
            { id: 'size_mid', text: 'ä¸­', x: 0.28, y: 0.6, w: 0.1, h: 0.1, action: () => { state.lineWidth = 8; } },
            { id: 'size_large', text: 'ç²—', x: 0.41, y: 0.6, w: 0.1, h: 0.1, action: () => { state.lineWidth = 15; } },
        ]
    };
    
    // ç®€å•çš„æ‚¬åœè®¡æ—¶å™¨
    let hoverTimer = 0;
    let lastHoverBtn = null;

    // --- 2. å‡ ä½•è®¡ç®—è¾…åŠ©å‡½æ•° ---
    
    function distance(p1, p2) {
        return Math.hypot(p1.x - p2.x, p1.y - p2.y);
    }

    // æ£€æµ‹é£ŸæŒ‡æ˜¯å¦ä¼¸ç›´ï¼Œå…¶ä»–æ‰‹æŒ‡å¼¯æ›² (ç”¨äºæ£€æµ‹ UI ç‚¹å‡»)
    function isIndexPointing(lm) {
        // ç®€å•åˆ¤æ–­ï¼šé£ŸæŒ‡æŒ‡å°–æœ€é«˜(yæœ€å°)ï¼Œä¸”é«˜äºå…¶ä»–æŒ‡å°–
        // è¿™é‡Œç”¨ y åæ ‡åˆ¤æ–­å‚ç›´æ–¹å‘ï¼ˆæ³¨æ„ MediaPipe yè½´å‘ä¸‹å¢å¤§ï¼‰
        // æ›´å¥½çš„é€»è¾‘ï¼šé£ŸæŒ‡ä¼¸ç›´ï¼Œä¸­æŒ‡æ— åæŒ‡å°æŒ‡å¼¯æ›²
        const indexStraight = lm[8].y < lm[6].y;
        const middleBent = lm[12].y > lm[10].y;
        const ringBent = lm[16].y > lm[14].y;
        const pinkyBent = lm[20].y > lm[18].y;
        return indexStraight && middleBent && ringBent && pinkyBent;
    }

    // æ£€æµ‹æ‰‹æŒå¼ å¼€
    function isPalmOpen(lm) {
        // äº”æŒ‡å…¨éƒ¨ä¼¸ç›´
        return lm[8].y < lm[6].y && lm[12].y < lm[10].y && lm[16].y < lm[14].y && lm[20].y < lm[18].y && lm[4].x < lm[3].x; // æ‹‡æŒ‡å¤§æ¦‚åˆ¤æ–­
    }

    // æ£€æµ‹æåˆ (é£ŸæŒ‡+æ‹‡æŒ‡)
    function isPinch(lm) {
        return distance(lm[8], lm[4]) < 0.05;
    }

    // æ£€æµ‹å‰ªåˆ€æ‰‹ (é£ŸæŒ‡+ä¸­æŒ‡ä¼¸ç›´ï¼Œå…¶ä»–å¼¯æ›²)
    function isVictory(lm) {
        const indexStraight = lm[8].y < lm[6].y;
        const middleStraight = lm[12].y < lm[10].y;
        const ringBent = lm[16].y > lm[14].y;
        const pinkyBent = lm[20].y > lm[18].y;
        return indexStraight && middleStraight && ringBent && pinkyBent;
    }

    // --- 3. æ ¸å¿ƒé€»è¾‘å¾ªç¯ ---

    function onResults(results) {
        if (loadingDiv.style.display !== 'none') loadingDiv.style.display = 'none';

        // è°ƒæ•´ç”»å¸ƒå°ºå¯¸
        canvasElement.width = window.innerWidth;
        canvasElement.height = window.innerHeight;
        
        // 1. ç»˜åˆ¶è§†é¢‘èƒŒæ™¯
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
        
        // 2. å¤„ç†é›ªèŠ±æ¶ˆæ•£åŠ¨ç”»
        if (isDissolving) {
            updateAndDrawParticles();
            // å¦‚æœç²’å­å¾ˆå°‘äº†ï¼Œåœæ­¢æ¶ˆæ•£æ¨¡å¼
            if (particles.length === 0) {
                isDissolving = false;
            }
        } else {
            // 3. ç»˜åˆ¶ç°æœ‰ç¬”è¿¹ (åº”ç”¨ç¼©æ”¾)
            drawStrokes();
        }

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            // å¤„ç†æ‰‹åŠ¿é€»è¾‘
            handleGestures(results.multiHandLandmarks);

            // ç»˜åˆ¶éª¨æ¶
            for (const landmarks of results.multiHandLandmarks) {
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 1});
                drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 3});
            }
        }

        // 4. ç»˜åˆ¶ UI (å¦‚æœæ‰“å¼€)
        if (state.isMenuOpen) {
            drawUI();
        }

        canvasCtx.restore();
    }

    function handleGestures(allLandmarks) {
        const lm = allLandmarks[0]; // ä¸»è¦ä½¿ç”¨ç¬¬ä¸€åªæ‰‹
        const now = Date.now();

        // ------------------ èœå•åˆ‡æ¢é€»è¾‘ (Palm Open) ------------------
        if (state.menuCooldown > 0) state.menuCooldown--;

        if (isPalmOpen(lm)) {
            if (state.menuCooldown === 0) {
                // åˆ‡æ¢èœå•çŠ¶æ€
                state.isMenuOpen = !state.isMenuOpen;
                state.menuCooldown = 30; // è®¾ç½®å†·å´æ—¶é—´
                // å¦‚æœæ‰“å¼€èœå•ï¼Œé‡ç½®å…¶ä»–æ¨¡å¼
                if(state.isMenuOpen) {
                    currentStroke = null;
                }
            }
        }

        // ------------------ èœå•äº¤äº’é€»è¾‘ ------------------
        if (state.isMenuOpen) {
            // æ£€æµ‹é£ŸæŒ‡ä½ç½®è¿›è¡Œ UI é€‰æ‹©
            const indexTip = lm[8]; // å½’ä¸€åŒ–åæ ‡ 0-1
            checkUISelection(indexTip);
            return; // èœå•æ‰“å¼€æ—¶ä¸è¿›è¡Œç»˜å›¾
        }

        // ------------------ é›ªèŠ±æ¶ˆæ•£ (Victory) ------------------
        if (isVictory(lm) && !isDissolving && strokes.length > 0) {
            startDissolve();
            return;
        }

        // ------------------ åŒæ‰‹ç¼©æ”¾ (Two Index Fingers) ------------------
        if (allLandmarks.length === 2) {
            // å‡è®¾ä¸¤åªæ‰‹éƒ½åªä¼¸å‡ºäº†é£ŸæŒ‡
            const h1 = allLandmarks[0];
            const h2 = allLandmarks[1];
            // ç®€å•åˆ¤æ–­ï¼šæ˜¯ä¸æ˜¯éƒ½æ˜¯é£ŸæŒ‡ä¼¸ç›´æ¨¡å¼? æˆ–è€…æ˜¯ç®€å•çš„è·ç¦»æ£€æµ‹
            // ä¸ºäº†ä½“éªŒæµç•…ï¼Œåªè¦æ£€æµ‹åˆ°ä¸¤åªæ‰‹éƒ½åœ¨ï¼Œå°±è®¡ç®—ä¸¤æ‰‹é£ŸæŒ‡å°–è·ç¦»
            const dist = distance(h1[8], h2[8]);
            
            if (state.mode !== 'ZOOMING') {
                state.mode = 'ZOOMING';
                state.zoomStartDist = dist;
                state.baseScale = state.scale;
            } else {
                // è®¡ç®—æ–°çš„ç¼©æ”¾æ¯”ä¾‹
                const ratio = dist / state.zoomStartDist;
                // é™åˆ¶ç¼©æ”¾èŒƒå›´
                let newScale = state.baseScale * ratio;
                if (newScale < 0.5) newScale = 0.5;
                if (newScale > 5) newScale = 5;
                state.scale = newScale;
            }
            return; // ç¼©æ”¾æ—¶ä¸ç»˜å›¾
        } else {
            if (state.mode === 'ZOOMING') state.mode = 'IDLE';
        }

        // ------------------ ç»˜å›¾/æ“¦é™¤ (Pinch) ------------------
        if (isPinch(lm)) {
            // åæ ‡è½¬æ¢
            const x = lm[8].x * canvasElement.width;
            const y = lm[8].y * canvasElement.height;

            // é€†å‘ç¼©æ”¾åæ ‡ï¼Œä»¥ä¾¿å­˜å‚¨åœ¨åŸå§‹åæ ‡ç³»ä¸­
            // (x - center) / scale + center
            const centerX = canvasElement.width / 2;
            const centerY = canvasElement.height / 2;
            const rawX = (x - centerX) / state.scale + centerX;
            const rawY = (y - centerY) / state.scale + centerY;

            if (state.tool === 'PEN') {
                if (!currentStroke) {
                    currentStroke = {
                        color: state.color,
                        size: state.lineWidth,
                        points: []
                    };
                    strokes.push(currentStroke);
                }
                currentStroke.points.push({x: rawX, y: rawY});
            } else if (state.tool === 'ERASER') {
                // æ©¡çš®æ“¦é€»è¾‘ï¼šåˆ é™¤é™„è¿‘çš„ç‚¹
                erasePoints(rawX, rawY);
            }
        } else {
            currentStroke = null;
        }
    }

    // --- 4. åŠŸèƒ½å®ç°ç»†èŠ‚ ---

    function drawStrokes() {
        const centerX = canvasElement.width / 2;
        const centerY = canvasElement.height / 2;

        canvasCtx.save();
        // åº”ç”¨å…¨å±€ç¼©æ”¾ï¼šä»¥å±å¹•ä¸­å¿ƒä¸ºé”šç‚¹
        canvasCtx.translate(centerX, centerY);
        canvasCtx.scale(state.scale, state.scale);
        canvasCtx.translate(-centerX, -centerY);

        canvasCtx.lineCap = 'round';
        canvasCtx.lineJoin = 'round';

        for (const stroke of strokes) {
            if (stroke.points.length < 1) continue;
            
            canvasCtx.beginPath();
            canvasCtx.lineWidth = stroke.size;
            canvasCtx.strokeStyle = stroke.color;

            canvasCtx.moveTo(stroke.points[0].x, stroke.points[0].y);
            for (let i = 1; i < stroke.points.length; i++) {
                canvasCtx.lineTo(stroke.points[i].x, stroke.points[i].y);
            }
            canvasCtx.stroke();
        }
        canvasCtx.restore();
    }

    function erasePoints(ex, ey) {
        const radius = 30 / state.scale; // æ©¡çš®æ“¦åŠå¾„éšç¼©æ”¾è°ƒæ•´
        // ç®€å•çš„éå†åˆ é™¤ (æ€§èƒ½ä¸€èˆ¬ä½†å¤Ÿç”¨)
        for (let s = strokes.length - 1; s >= 0; s--) {
            const stroke = strokes[s];
            stroke.points = stroke.points.filter(p => {
                const d = Math.hypot(p.x - ex, p.y - ey);
                return d > radius;
            });
            // å¦‚æœä¸€æ¡çº¿çš„ç‚¹è¢«åˆ å…‰äº†ï¼Œç§»é™¤è¯¥çº¿
            if (stroke.points.length === 0) {
                strokes.splice(s, 1);
            }
        }
    }

  function drawUI() {
    const w = canvasElement.width;
    const h = canvasElement.height;
    
    // --- 1. ç»˜åˆ¶ä¸»èƒŒæ™¯é¢æ¿ ---
    canvasCtx.save();
    // æ•´ä¸ªé¢æ¿ä¹Ÿéœ€è¦ç¿»è½¬ï¼Œå¦åˆ™é¢æ¿ä½ç½®ä¼šåœ¨å±å¹•ç›¸åä¸€ä¾§
    canvasCtx.translate(w, 0);
    canvasCtx.scale(-1, 1);

    canvasCtx.fillStyle = 'rgba(50, 50, 50, 0.85)';
    // æ³¨æ„ï¼šè¿™é‡Œçš„åæ ‡ä¾ç„¶ä½¿ç”¨åŸå§‹ uiConfig æ¯”ä¾‹
    canvasCtx.beginPath();
    canvasCtx.roundRect(w * uiConfig.x, h * uiConfig.y, w * uiConfig.width, h * uiConfig.height, 20);
    canvasCtx.fill();
    canvasCtx.strokeStyle = 'white';
    canvasCtx.lineWidth = 2;
    canvasCtx.stroke();
    canvasCtx.restore();

    // --- 2. ç»˜åˆ¶æŒ‰é’®å†…å®¹ ---
    for (const btn of uiConfig.buttons) {
        const bx = w * btn.x;
        const by = h * btn.y;
        const bw = w * btn.w;
        const bh = h * btn.h;

        // è®¡ç®—æŒ‰é’®ä¸­å¿ƒç‚¹ï¼Œç”¨äºæ—‹è½¬/ç¿»è½¬ä¸­å¿ƒ
        const centerX = bx + bw / 2;
        const centerY = by + bh / 2;

        canvasCtx.save();
        
        /** * æ ¸å¿ƒé€»è¾‘ï¼š
         * 1. ç§»åŠ¨åˆ°æŒ‰é’®ä¸­å¿ƒ
         * 2. æ°´å¹³ç¿»è½¬ (-1, 1)
         * 3. å†ç§»å›ç»˜åˆ¶èµ·ç‚¹ (ç›¸å¯¹äºä¸­å¿ƒçš„è´Ÿåç§»)
         */
        canvasCtx.translate(centerX, centerY);
        canvasCtx.scale(-1, 1);
        canvasCtx.translate(-centerX, -centerY);

        // --- å¼€å§‹ç»˜åˆ¶æŒ‰é’®ç»†èŠ‚ (åæ ‡ä¾ç„¶ä½¿ç”¨ bx, by) ---

        // é«˜äº®é€‰ä¸­çŠ¶æ€
        if (lastHoverBtn === btn) {
            canvasCtx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            canvasCtx.fillRect(bx - 5, by - 5, bw + 10, bh + 10);
        }

        // å½“å‰æ¿€æ´»çš„å·¥å…·/é¢œè‰²é«˜äº®
        let isActive = false;
        if (btn.id.includes(state.tool.toLowerCase())) isActive = true;
        if (btn.color && btn.color === state.color) isActive = true;
        
        // ç²—ç»†æ£€æŸ¥
        if (btn.id === 'size_small' && state.lineWidth === 3) isActive = true;
        if (btn.id === 'size_mid' && state.lineWidth === 8) isActive = true;
        if (btn.id === 'size_large' && state.lineWidth === 15) isActive = true;

        if (isActive) {
            canvasCtx.strokeStyle = '#00FF00';
            canvasCtx.lineWidth = 4;
            canvasCtx.strokeRect(bx, by, bw, bh);
        }

        if (btn.type === 'color') {
            canvasCtx.fillStyle = btn.color;
            canvasCtx.fillRect(bx, by, bw, bh);
        } else {
            canvasCtx.fillStyle = 'rgba(255,255,255,0.1)';
            canvasCtx.fillRect(bx, by, bw, bh);
            
            canvasCtx.fillStyle = 'white';
            canvasCtx.font = '20px Arial';
            canvasCtx.textAlign = 'center';
            canvasCtx.textBaseline = 'middle';
            // æ–‡å­—ç°åœ¨ä¼šæ­£ç¡®æ˜¾ç¤ºï¼Œä¸å†æ˜¯åçš„
            canvasCtx.fillText(btn.text, bx + bw / 2, by + bh / 2);
        }

        canvasCtx.restore(); // æ¢å¤åˆ°æœªç¿»è½¬çŠ¶æ€ï¼Œå‡†å¤‡ç»˜åˆ¶ä¸‹ä¸€ä¸ªæŒ‰é’®
    }
}
    function checkUISelection(indexTip) {
        // indexTip æ˜¯å½’ä¸€åŒ–åæ ‡ 0-1
        let hovered = null;
        for (const btn of uiConfig.buttons) {
            if (indexTip.x >= btn.x && indexTip.x <= btn.x + btn.w &&
                indexTip.y >= btn.y && indexTip.y <= btn.y + btn.h) {
                hovered = btn;
                break;
            }
        }

        if (hovered) {
            if (lastHoverBtn === hovered) {
                hoverTimer++;
                // ç»˜åˆ¶è¿›åº¦åœˆ
                const bx = canvasElement.width * hovered.x;
                const by = canvasElement.height * hovered.y;
                canvasCtx.beginPath();
                canvasCtx.arc(bx, by, 10, 0, (hoverTimer / 30) * Math.PI * 2);
                canvasCtx.strokeStyle = 'cyan';
                canvasCtx.stroke();

                if (hoverTimer > 20) { // æ‚¬åœçº¦ 20 å¸§è§¦å‘
                    if (hovered.action) hovered.action();
                    if (hovered.type === 'color') state.color = hovered.color;
                    
                    // è§¦å‘åé¦ˆåŠ¨ç”»æˆ–å£°éŸ³ï¼ˆè¿™é‡Œç®€å•é‡ç½®ï¼‰
                    hoverTimer = 0;
                    lastHoverBtn = null; // å¼ºåˆ¶é‡ç½®é˜²æ­¢è¿ç»­è§¦å‘
                }
            } else {
                lastHoverBtn = hovered;
                hoverTimer = 0;
            }
        } else {
            lastHoverBtn = null;
            hoverTimer = 0;
        }
    }

    // --- 5. é›ªèŠ±ç²’å­ç³»ç»Ÿ ---

    function startDissolve() {
        isDissolving = true;
        particles = [];
        
        // å°†æ‰€æœ‰ç¬”è¿¹è½¬åŒ–ä¸ºç²’å­
        const centerX = canvasElement.width / 2;
        const centerY = canvasElement.height / 2;

        for (const stroke of strokes) {
            for (let i = 0; i < stroke.points.length; i+=2) { // é‡‡æ ·ï¼Œä¸ç”¨æ¯ä¸ªç‚¹éƒ½è½¬
                const p = stroke.points[i];
                // åº”ç”¨å½“å‰çš„ç¼©æ”¾çŠ¶æ€è®¡ç®—å±å¹•å®é™…ä½ç½®ï¼Œä½œä¸ºç²’å­åˆå§‹ä½ç½®
                const screenX = (p.x - centerX) * state.scale + centerX;
                const screenY = (p.y - centerY) * state.scale + centerY;

                particles.push({
                    x: screenX,
                    y: screenY,
                    vx: (Math.random() - 0.5) * 2, // éšæœºæ¨ªå‘æ¼‚ç§»
                    vy: Math.random() * 2 + 1,     // å‘ä¸‹æ‰è½é€Ÿåº¦
                    color: stroke.color,
                    size: stroke.size * state.scale,
                    alpha: 1.0
                });
            }
        }
        // æ¸…ç©ºç¬”è¿¹
        strokes = [];
    }

    function updateAndDrawParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.alpha -= 0.015; // æ¸éš
            p.vx += (Math.random() - 0.5) * 0.1; // éšæœºæ‘†åŠ¨

            if (p.alpha <= 0 || p.y > canvasElement.height) {
                particles.splice(i, 1);
            } else {
                canvasCtx.globalAlpha = p.alpha;
                canvasCtx.fillStyle = p.color;
                canvasCtx.beginPath();
                canvasCtx.arc(p.x, p.y, p.size / 2, 0, Math.PI * 2);
                canvasCtx.fill();
            }
        }
        canvasCtx.globalAlpha = 1.0;
    }

    // --- 6. å¯åŠ¨ MediaPipe Hands ---
    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7
    });

    hands.onResults(onResults);

    const camera = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 1280,
        height: 720
    });
    
    camera.start();

</script>
</body>
</html>

